{"pages":[{"title":"关于","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"JavaScript","text":"运算符##自增++ 自增1运算 前置自增时,会进行先自增1操作再进行赋值;后置自增时,会先进行赋值再自增1 12345678910//后置自增var a = 0;var b = a++;console.log(a);//a=1console.log(b); //b=0//前置自增var a = 0;var b = ++a;console.log(a); //a=1console.log(b); //b=1 自增不仅适用于整数，还适用于字符串、布尔值、浮点数值和对象 字符串 123456789var a = '1';console.log(++a); // 2var a = '1e1'; //10的1次方console.log(++a); // 11// 16进制var a = '0xF'; //15console.log(++a); //16 布尔值 12345var a = trueconsole.log(++a) // 2var a = false;console.log(++a); // 1 浮点 12var a = 1.1;console.log(++a); //2.1 对象 12345678910var a = { a:10};console.log(++a); //NaNvar a = [10];console.log(++a); // 11var a = [10,11];console.log(++a) // NaN 立即调用函数表达式（IIFE）IIFE: Immediately Invoked Function Expression，意为立即调用的函数表达式，也就是说，声明函数的同时立即调用这个函数 写法12345678// 常见写法(function () { //code})();(function () { //code}()) 立即调用函数的写法有很多，规则就是 在写立即调用函数时要避免解释器把它当成声明式 例如 以下写法都可以实现上面的效果 12345678910111213141516171819202122232425262728293031!function () { //code}()+function () { //code}()+function () { //code}()~function () { //code}()delete function () { //code}()void function () { //code}()false || function () { //code}()0 == function () { //code}() 局部作用域在es6之前立即调用函数主要用于创建局部作用域 例如，下面代码是想间隔1秒依次输出0，1，2，3，4； 12345for (var i = 0; i &lt; 5; i++) { setTimeout(() =&gt; { console.log(i); }, i * 1000)} 但是并不会按预想的输出，而是输出5次5 解决这个问题的其中一个方法就是替换为立即调用函数 1234567for (var i = 0; i &lt; 5; i++) { (function (index) { setTimeout(() =&gt; { console.log(index); }, i * 1000) })(i)} 这样就能按我们预想的输出 注意立即调用函数函数还有以下规律 在IIFE中和IIFE外部同时声明同名变量时，变量之间互不影响 123456var a = 0;(function () { var a = 1000 console.log(a); // 1000})()console.log(a); // 03 当立即调用函数有函数名时，对该函数名进行赋值无效 12345(function a() {a = 1000console.log(a); // a(){ a = 1000;console.log(a);}})()//要想输出1000，需要对a进行声明（let、const、var） 模块在es2015之前JavaScript是没有模块，模块是社区制定的有用于服务端的CommonJS和浏览器端的AMD， CommonJS123456789//导入 //index.jsconst a = require('./moduleA.js')console.log(a) // 10//导出 // moduleA.jsconst a = 10;module.exports = a; AMDAMD(Asynchronous Module Definition):异步模块加载机制，AMD模块也借鉴CommonJS模块化使用require来导入模块 123456789101112// 导入//index.jsrequire(['./moduleA.js'], function(a) { console.log(a);});//导出//moduleA.jsdefine(function(require) { var a = 10; return a;}); html页面 123&lt;!-- 引入requireJS 以实现模块化 --&gt;&lt;script src=&quot;./require.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./b.js&quot;&gt;&lt;/script&gt; ES2015在ES2015之后推出了模块，import,export 123456789101112//导入import {a} from './moduleA.js'//导出const a = 10export {a}//默认导出const a = 10export default a//这时导入就会要这样import a from './moduleA.js'","link":"/2021/11/27/JavaScript/"},{"title":"JavaScript中localeCompare对字符串数字排序问题","text":"代码1234567891011const arr =['Cu67%%','Ag5%%','Ca13%%','Fe3O415%%','Ca12%%','Cu50%%','Ag16%%','Fe3O430%%','Ca4%%']function stringSort (a,b){ //升序排序 return a.localeCompare(b)}arr.sort(stringSort)console.log(arr)// ['Ag16%%', 'Ag5%%', 'Ca12%%', 'Ca13%%', 'Ca4%%', 'Cu50%%', 'Cu67%%', 'Fe3O415%%', 'Fe3O430%%'] 问题可以看出Ag16%%排在了Ag5%%前面，粗看好像是对数组进行降序排序了；但是在后面的每一项却是正常的升序排序。如果只看元素的排序，每一项确实是按照正常的顺序进行排序的 所以猜测应该是字符串数字的原因 验证猜测 12345678const arr = ['67','5','13','15','12','50','16','30','4']function stringSort (a,b){ return a.localeCompare(b)}arr.sort(stringSort)console.log(arr) // ['12', '13', '15', '16', '30', '4', '5', '50', '67'] 果然字符串的数字排序有问题 对于0-9数字在字符编码中肯定是连续的，所以不可能会出现这中情况 然后查询文档String.prototype.localeCompare() - JavaScript | MDN (mozilla.org)，[JavaScript localeCompare() 方法](JavaScript localeCompare() 方法 (w3school.com.cn)) 得到 localeCompare() 方法提供的比较字符串的方法，考虑了默认的本地排序规则。ECMAscript 标准并没有规定如何进行本地特定的比较操作，它只规定该函数采用底层操作系统提供的排序规则。 同时 localeCompare接受三个参数 1localeCompare(compareString[, locales[, options]]) 然后在options中找到numeric选项 是否指定使用数字排序, 像这样 “1” &lt; “2” &lt; “10”. 可能的值是 true 和 false; 默认为 false. 这个选项能被通过options 属性设置或通过 Unicode 扩展。假如两个都被设置了， 则 options 优先。 实现不用必须支持这个属性 12345678const arr = ['67','5','13','15','12','50','16','30','4']function stringSort (a,b){ return a.localeCompare(b,undefined,{numeric:true})}arr.sort(stringSort)console.log(arr) //['4', '5', '12', '13', '15', '16', '30', '50', '67'] 至此字符串数字排序已经正常 验证12345678910const arr =['Cu67%%','Ag5%%','Ca13%%','Fe3O415%%','Ca12%%','Cu50%%','Ag16%%','Fe3O430%%','Ca4%%']function stringSort (a,b){ return a.localeCompare(b,undefined,{numeric:true})}arr.sort(stringSort)console.log(arr) //['Ag5%%', 'Ag16%%', 'Ca4%%', 'Ca12%%', 'Ca13%%', 'Cu50%%', 'Cu67%%', 'Fe3O415%%', 'Fe3O430%%'] 问题解决","link":"/2021/11/30/JavaScript%E4%B8%ADlocaleCompare%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E5%AD%97%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"},{"title":"fetch设置超时","text":"在用nextJs做服务端渲染时,服务端都是使用的fetch去发送接口,但是都没有进行封装;在昨天看见fetch也可以超时取消请求,就想着尝试一下 超时取消请求主要是使用Promise.race、AbortController来实现 123456789101112131415const timeout = 2000const controller = new AbortController();const signal = controller.signalPromise.race(()=&gt;{ return new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ controller.abort() reject(&quot;timeout&quot;) },timeout) })},()=&gt;{ return new Promise((resolve,reject)=&gt;{ fetch(url,{signal}).then(res=&gt;res.json()) })}) 然后超时大致就是这样,不过AbortController还在实验中存,而且存在一定兼容问题;不推荐生产环境使用 贴一个fetch的简单封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103class Service { constructor(config) { return this.init(config); } //把get请求的参数转成query queryToUrl(query = {}) { if (query) { let keys = Object.keys(query); const querys = keys.map((key) =&gt; { return `${key}=${query[key]}`; }); if (querys.length) { return &quot;?&quot; + querys.join(&quot;&amp;&quot;); } } return &quot;&quot;; } // 构建请求配置 getConfig(config) { let params = { method: config.method || &quot;GET&quot;, headers: { &quot;Content-Type&quot;: &quot;application/json&quot;, ...config.headers, }, }; let url = &quot;&quot;; url = config.url; if (params.method === &quot;GET&quot;) { url += this.queryToUrl(config.data); } if (params.method === &quot;POST&quot;) { const type = Object.prototype.toString.call(config.data || {}); if (type === &quot;[object Object]&quot;) { params.body = JSON.stringify(config.data); } if (type === &quot;[object FormData]&quot;) { params.body = config.data; } } params.url = url; return params; } //发送请求 init(config) { const { url, ...params } = this.getConfig(config); const raceFnArr = []; const controller = new AbortController(); params.signal = controller.signal; //fetch const fetchFn = (resolve, reject) =&gt; { fetch(url, params) .then((res) =&gt; { // 根据 Content-Type 调用json()或者text() const type = res.headers.get(&quot;Content-Type&quot;); switch (type) { case &quot;application/json&quot;: return res.json(); default: return res.text(); } }) .then((res) =&gt; { resolve(res); }) .catch((err) =&gt; { reject(err); }); }; raceFnArr.push(fetchFn); //如果传入timeout if (typeof config.timeout !== &quot;undefined&quot;) { const fn = function (resolve, reject) { setTimeout(() =&gt; { //超时取消请求,和reject controller.abort(); reject(&quot;timeout&quot;); }, config.timeout); }; raceFnArr.push(fn); } return Promise.race(raceFnArr.map((fn) =&gt; new Promise(fn))); }}function service(config) { return new Service(config);}service({ url: &quot;http://localhost:3000/post&quot;, method: &quot;POST&quot;, data: { user:'user1' },}) .then((res) =&gt; { console.log(res); }) .catch((err) =&gt; { console.error(err); }); 参考AbortController.AbortController() - Web API 接口参考 | MDN (mozilla.org)","link":"/2021/12/06/fetch/"},{"title":"git代理","text":"由于国情的原因，经常访问github会出现连接重置;因为我是gitee和github都在用，所以记录一下git针对github的代理 以下环境均在windows git代理http和https 只针对github进行代理 123456git config --global http.https://github.com.proxy http://127.0.0.1:10809git config --global https.https://github.com.proxy http://127.0.0.1:10809&lt;!-- more --&gt;#socks5git config --global http.https://github.com.proxy socks5://127.0.0.1:10808git config --global https.https://github.com.proxy socks5://127.0.0.1:10808 取消代理 123456git config --global --unset http.https://github.com.proxy http://127.0.0.1:10809git config --global --unset https.https://github.com.proxy http://127.0.0.1:10809# socks5git config --global --unset http.https://github.com.proxy socks5://127.0.0.1:10808git config --global --unset https.https://github.com.proxy socks5://127.0.0.1:10808 以上只针对http/https有效，对ssh无效 ssh代理 打开git bash 输入 1vim ~/.ssh/config 或者找到C:\\Users\\(你的用户名)\\.ssh文件夹下的config文件（如果没有新建一个） 用文本编辑器打开config（我这里用的Sublime Text） 填入以下内容保存即可 12345678910111213 #全局 #ProxyCommand &quot;D:\\Program Files\\Git\\mingw64\\bin\\connect.exe&quot; -S 127.0.0.1:10808 %h %p#githubHost github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa.github #windows代理 # https||http # ProxyCommand &quot;D:\\Program Files\\Git\\mingw64\\bin\\connect.exe&quot; -H 127.0.0.1:10809 %h %p #socks5 ProxyCommand &quot;D:\\Program Files\\Git\\mingw64\\bin\\connect.exe&quot; -S 127.0.0.1:10808 %h %p -S:使用socks5 connect.exe:connect.exe一般在git的安装路径\\mingw64\\bin\\位置（没有下载一个即可） %h:Host占位符 %p:Port占位符","link":"/2021/12/10/git%E4%BB%A3%E7%90%86/"},{"title":"isNaN和Number.isNaN","text":"isNaNisNaN判断的依据是根据传入参数是否能成功转换为数字(==)，如果转换成功返回false，失败则返回true，并不是严格判断是否等于NaN 12Number('test') //NaNisNaN('test') //true Number.isNaNNumber.isNaN是严格判断(===)传入参数是否为NaN，也就是不会进行转换 12isNaN('test') //trueNumber.isNaN('test') //false","link":"/2022/02/09/isNaN%E5%92%8CNumber-isNaN/"},{"title":"关于null大于等于0为true的原因","text":"代码如下 12345null &gt; 0 //falsenull &lt; 0 //falsenull == 0 //falsenull &gt;= 0 //truenull &lt;= 0 //true 出现这种诡异的情况的原因是因为JavaScript的隐式转换，因为对于&gt;、&lt;关系运算时，需要左右两边是数字时才能进行运算 也就是说上面的null在做关系运算时会被转换为数字 也就是 0 ，所以0既不大于0也不小于0，因此得到的结果是false 而对于相等运算ecma中没有null和number的情况因此返回false 因此对于在做null &gt;= 0运算时null会被尝试转换为数字0，所以结果为true 参考ECMAScript® 2022 Language Specification (tc39.es) 从 null &gt;= 0 说起 - Franky - 博客园 (cnblogs.com)","link":"/2022/01/22/%E5%85%B3%E4%BA%8Enull%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E0%E4%B8%BAtrue%E7%9A%84%E5%8E%9F%E5%9B%A0/"},{"title":"webrtc","text":"webrtc api webrtc演示","link":"/2022/02/06/webrtc/"},{"title":"前端跨域","text":"跨域解决方案JSONPcors（Cross-Origin Resource Sharing）,跨域资源共享代理","link":"/2021/12/05/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F/"},{"title":"工具","text":"工具fuitefuite一款用于在web中查找内存泄漏的工具 jsPDFjsPDF用于在JavaScript中生成pdf","link":"/2022/01/10/%E5%B7%A5%E5%85%B7/"},{"title":"事件循环","text":"事件循环(Event Loop)浏览器环境执行栈执行栈其实就是存放执行上下文环境的地方,按照栈的先进后出的原则,进行入栈和出栈;因为js是单线程,同一时间只能执行一个方法,所以当有一连串的方法被调用时,js引擎就会把同步代码(异步会不同)依次放入执行栈中等待执行 每当执行完一个方法时,就会销毁这个方法对应的执行上下文环境,并回到上一个方法的执行上下文环境,一直到执行栈被清空 任务队列上面是针对同步代码来说,当遇到异步代码时,js引擎不会等待返回结果,而是将其挂起;只有异步有结果后,js才会将该异步的回调放入任务队列中 同时放入任务队列的回调也不会被立即执行,只有当执行栈中所有任务被执行完后,才会去查找任务队列要执行的回调,并将其放入执行栈中执行 如此的重复就是事件循环(event loop) 微任务宏任务在任务队列中又可细分为微任务队列,宏任务队列,而宏任务和微任务的执行顺序会不同 宏任务以下属于宏任务 setTimeout setInterval setImmediate(node环境,浏览器中只有ie10,11支持) 微任务以下属于微任务 new Promise() .then .catch .finally queueMicrotask MutationObserver 1234567891011121314151617setTimeout(()=&gt;{ console.log(1);})new Promise((resolve)=&gt;{ console.log(2); resolve(3)}).then(res=&gt;{ console.log(res); return 4}).then(res=&gt;{ console.log(res);})console.log(5);//输出: 2 =&gt; 5 =&gt; 3 =&gt; 4 =&gt; 1 也就是说每当执行栈执行完毕时,就会先执行微任务队列中需要执行的回调,然后再去执行宏任务中的回调 参考JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志 (ruanyifeng.com) 在 JavaScript 中通过 queueMicrotask() 使用微任务 - Web API 接口参考 | MDN (mozilla.org) window.setImmediate - Web API 接口参考 | MDN (mozilla.org)","link":"/2021/12/03/%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%AE%8F%E4%BB%BB%E5%8A%A1/"},{"title":"服务端渲染","text":"nextJs基于React的一款服务端渲染的框架 nuxtJs基于Vue的服务端渲染框架 remixJs基于React的服务端渲染框架，不同于next、nuxt;remix可以对页面进行分块返回html","link":"/2022/02/05/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"},{"title":"在Visual Studio Code中调试web应用","text":"第一步 - 打开调试使用快捷键（Ctrl+Shift+D）或者点解下图位置打开调试 第二步 - 配置下面都是用edge来进行演示 点击 创建launch.json，默认会有chrome，edge，node等选项，如果需要在firefox中调试需要安装debugger for firefox 扩展 如果已经创建过点击 运行和调试 旁边的小齿轮就可打开launch.json进行配置 launch这里选择的是edge:launch，VSC会默认添加以下配置 1234567{ &quot;type&quot;: &quot;pwa-msedge&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Edge against localhost&quot;, &quot;url&quot;: &quot;http://localhost:3000&quot;, &quot;webRoot&quot;: &quot;${workspaceFolder}&quot;} attach在launch.json 点击添加配置 选择 Edge:Attach 1234567{ &quot;name&quot;: &quot;Edge:Attach&quot;, &quot;port&quot;: 9222, &quot;request&quot;: &quot;attach&quot;, &quot;type&quot;: &quot;pwa-msedge&quot;, &quot;webRoot&quot;: &quot;${workspaceFolder}&quot;} 这里的&quot;port&quot;: 9222是浏览器的一个调试端口，也可以指定其他端口，前提是没有被占用 配置项 type - 应用该调试配置的调试器类型，可能值 pwa-mesegde msegde chrome firefox node request - 启动调试的方式， 可能值 launch attach launch - 启动新的界面进行调试；浏览器会打开新的标签页，插件这些不会生效 attach - 与上面一致区别在于在这个窗口中，插件这些会保留 name - 用于VSC展示调试的名字 url - 需要调试的地址，自己web应用的地址 webRoot - web应用的根目录 port - attach时必须配置，指定浏览器调试的端口 第三步如果是launch模式请跳过该步骤 关闭所有的edge实例 在命令行中输入以下，然后回车 123# 指定9222为调试端口，启动edge# 如果是chrome只需要把msedge换为chromestart msedge.exe --remote-debugging-port=9222 此处的端口要与VSC中配置的一致，不然VSC不能连接浏览器 这时会打开一个edge窗口 正常的话在浏览器输入 1localhost:9222/json/list 就能看见以下界面 但是在我测试几次下来VSC经常会报不能连接；原因就是edge并没有被全部关闭，还有后台进程，只需将所有的进程关闭重新执行上面的命令即可 这里推荐使用这个命令来关闭 12# 这个命令会强行关闭edgetaskkill /im msedge.exe /F 第四步 - 启动:rocket:launch在VSC中打好断点，然后选择配置好的edge-launch的配置，按F5或者点击开始调试；即可启动调试 可以看见浏览器会自动停在断点位置，同时插件没有在该窗口生效 attach选择edge-attach的配置，按F5或者开始调试; 启动后VSC会去连接浏览器，连接成功会出现下面的悬浮窗 这时后在浏览器中输入url，就会在打断点的位置停止 其他上面的Edge配置也适用chrome(毕竟这两都是Chromium内核) 如果要在firefox中debugger需要在VSC中安装 Debugger for Firefox 扩展，更多信息参考该扩展的说明 Debugging in Visual Studio Code Microsoft Edge 开发工具协议 - Microsoft Edge Development | Microsoft Docs Debugger for Firefox - Visual Studio Marketplace launch-and-attach · GitHub","link":"/2022/05/28/%E5%9C%A8visual%20studio%20code%E4%B8%AD%E8%B0%83%E8%AF%95web%E5%BA%94%E7%94%A8/"},{"title":"2022年6月14日","text":"2022年6月14日，原以为毕业不会发生在自己身上，没想到来得这么快；原计划是把这一年度过了来看，毕竟房子都租了，这下好了房也租了还被毕业了🙁","link":"/2022/06/14/2022%E5%B9%B46%E6%9C%8814%E6%97%A5/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"其它","slug":"其它","link":"/tags/%E5%85%B6%E5%AE%83/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}